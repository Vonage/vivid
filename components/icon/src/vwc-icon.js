import '@vonage/vvd-core';
import kefir from 'kefir';
import resolveIcon from './icon-resolve.autogenerated.js';
import { style } from '../vwc-icon.css.js';

const [
	SYMBOL_CONNECT,
	SYMBOL_DISCONNECT,
	SYMBOL_PROPERTY_TYPE,
	SYMBOL_PROPERTY_TYPE_SET
] = ['connect', 'disconnect', 'property-type', 'property-type-set'].map((name) => Symbol(name));

const
	PLACEHOLDER_ICON = `<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><style>@keyframes rotation { from { transform: rotate(0deg) } to { transform: rotate(360deg) } } g#circle { transform-origin: center center; animation: 1s rotation 0s linear infinite; } path { fill: var(--vvd-color-base-faint) }</style> <g id="circle"> <path d="M7.5 2C3.91014 2 1 4.91014 1 8.5C1 12.0899 3.91014 15 7.5 15C11.0899 15 14 12.0899 14 8.5C14 8.22386 14.2239 8 14.5 8C14.7761 8 15 8.22386 15 8.5C15 12.6421 11.6421 16 7.5 16C3.35786 16 0 12.6421 0 8.5C0 4.35786 3.35786 1 7.5 1C10.3622 1 12.7088 2.78366 13.9478 5.27753C14.0706 5.52484 13.9698 5.82492 13.7225 5.94778C13.4752 6.07065 13.1751 5.96977 13.0522 5.72247C11.9472 3.49834 9.90985 2 7.5 2Z"/><path d="M13.5 0C13.7761 0 14 0.223858 14 0.5V5.5C14 5.77614 13.7761 6 13.5 6H8.5C8.22386 6 8 5.77614 8 5.5C8 5.22386 8.22386 5 8.5 5H13V0.5C13 0.223858 13.2239 0 13.5 0Z"/></g></svg>`,
	PLACEHOLDER_DELAY = 500,  				// Start displaying placeholder if waiting more than this period of time
	PLACEHOLDER_TIMEOUT = 2000;				// Stop displaying placeholder if exceeding this period of time (will also stop one an icon is loaded)

const
	noop = ()=> {},
	memoize = (func)=> {
		const cache = new Map();
		return (key)=>
			cache.has(key)
				? cache.get(key)
				: (function(){
					const value = func(key);
					cache.set(key, value);
					return value;
				})();
	},
	resolveIconCache = memoize(resolveIcon);

/**
 * Displays an icon
 *
 * @element vwc-icon
 * @prop {string} type - The icon's identifier. A full list can be found at https://icons.vivid.vonage.com
 * @prop {"small" | "medium" | "large"} [size="medium"] - The icon's size.
 *
 */
class VWCIcon extends HTMLElement {

	constructor() {
		super();

		const
			rootEl = this.attachShadow({ mode: 'open' }),
			[styleEl, slotEl] = ['style', 'slot'].map((elName) => document.createElement(elName));

		styleEl.innerHTML = style.cssText;

		[SYMBOL_CONNECT, SYMBOL_DISCONNECT, SYMBOL_PROPERTY_TYPE_SET].forEach((symbol) => this[symbol] = noop);

		const
			connectStream = kefir.stream(({ emit }) => this[SYMBOL_CONNECT] = emit),
			typeProperty = kefir
				.concat([
					kefir.constant(this.getAttribute('type') || ''),
					kefir.stream(({ emit }) => this[SYMBOL_PROPERTY_TYPE_SET] = emit)
				])
				.skipDuplicates()
				.toProperty()
				.onValue(noop);

		// Update icon
		connectStream
			.flatMapLatest(() => {
				return typeProperty
					.filter(Boolean)
					.flatMapLatest((typeId)=> {
						const loadedSvgProperty = kefir.fromPromise(resolveIconCache(typeId)).toProperty();
						return kefir
							.merge([
								kefir
									.merge([
										kefir.later(PLACEHOLDER_DELAY, PLACEHOLDER_ICON),
										kefir.later(PLACEHOLDER_TIMEOUT, ''),
									])
									.takeUntilBy(loadedSvgProperty.ignoreErrors()),
								loadedSvgProperty
							]);
					})
					.takeUntilBy(kefir.stream(({ emit }) => this[SYMBOL_DISCONNECT] = emit).take(1));
			})
			.filter(() => this.isConnected)
			.onValue((svg) => slotEl.innerHTML = svg)
			.onError(console.warn);

		// Assemble element
		connectStream
			.take(1)
			.onValue(() => [styleEl, slotEl].forEach((el) => rootEl.appendChild(el)));

		// Update local vars/attributes
		kefir
			.concat([
				connectStream.take(1).ignoreValues(),
				typeProperty
			])
			.onValue((type) => type && this.setAttribute('type', type));
	}

	/**
	 * @private
	 */
	static get observedAttributes() {
		return ['type'];
	}

	/**
	 *
	 * @type {string}
	 */
	set type(value) {
		if (!value) {
			console.warn('Type must be a specified');
		} else {
			this[SYMBOL_PROPERTY_TYPE_SET](value);
		}
	}

	/**
	 *
	 * @type {string}
	 */
	get type() {
		return this[SYMBOL_PROPERTY_TYPE];
	}

	/**
	 *
	 * @type {"small" | "medium" | "large"}
	 */
	set size(value) {
		this.setAttribute('size', value);
	}

	/**
	 *
	 * @type {"small" | "medium" | "large"}
	 */
	get size() {
		return this.getAttribute('size');
	}

	/**
	 * @private
	 */
	connectedCallback() {
		this[SYMBOL_CONNECT]();
	}

	/**
	 * @private
	 */
	disconnectedCallback() {
		this[SYMBOL_DISCONNECT]();
	}

	/**
	 * @private
	 */
	attributeChangedCallback(attrName, oldValue, newValue) {
		switch (attrName) {
			case 'type':
				this.type = ['undefined', 'null'].includes(newValue) ? '' : newValue;
				break;
		}
	}
}

window.customElements.define('vwc-icon', VWCIcon);
export { VWCIcon };