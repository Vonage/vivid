import path from "path";
import kefir from "kefir";
import aws from "aws-sdk";
import parseArgs from "minimist";
import { createHash } from "crypto";
import { readdir, readFile, writeFile } from "fs";

const
	S3_UPLOAD_CONCURRENCY = 10,
	DEFAULT_BASE_URL = "https://d1zxmm6snown09.cloudfront.net",  //Dev
	DEFAULT_OUTPUT_FOLDER = "./src",
	DEFAULT_ICON_FOLDER = "./build/icon",
	DEFAULT_SKIP = false;

const
	{ awsAccessKey, awsAccessSecret, awsBucketName, awsSkipUpload = DEFAULT_SKIP, iconFolder = DEFAULT_ICON_FOLDER, baseUrl = DEFAULT_BASE_URL, outputFolder = DEFAULT_OUTPUT_FOLDER } = parseArgs(process.argv.slice(2), { alias: { "skip": "awsSkipUpload" } }),
	log = (message)=> console.log(["✓", message].join(' ')),
	warn = (message)=> console.warn(["✘", message].join(' '));

const
	baseDir = (filename)=> path.resolve(...[iconFolder, filename].filter(Boolean)),
	sha256 = (text)=>{
		const hasher = createHash('sha256');
		hasher.update(text);
		return hasher.digest('hex');
	};

const iconStream = kefir
	.fromNodeCallback((cb)=> readdir(baseDir(), cb))
	.flatten()
	.filter((filename)=> path.extname(filename.toLowerCase()) === ".svg")
	.map(baseDir)
	.flatMap((filename)=> {
		return kefir
			.fromNodeCallback((cb) => readFile(filename, 'utf8', cb))
			.map((content)=> ({ content, filename }));
	});

const createAwsResolver = function({ awsAccessKey, awsAccessSecret, awsBucketName, awsSkipUpload }){
	const pushToS3Bucket = (iconStream)=> {
		const s3 = new aws.S3({ secretAccessKey: awsAccessSecret, accessKeyId: awsAccessKey });
		return iconStream
			.flatMapConcurLimit(
				({ filename, content })=> {
					const hash = sha256(content);
					return kefir
						.fromNodeCallback((cb) => s3.upload({
							Bucket: awsBucketName,
							Key: [sha256(content), "svg"].join('.'),
							Body: content,
							ContentType: "image/svg+xml"
						}, cb))
						.map(({ Location: location, ETag: etag, key })=> ({ filename, content, location, etag, key }))
				}, S3_UPLOAD_CONCURRENCY);
	};

	const generateResolver = (iconStream)=>
		iconStream
			.scan((manifest, { filename, content })=> Object.assign(manifest, { [filename.match(/([^/]+)\..+$/)[1]]: [sha256(content), "svg"].join('.') }), {})
			.last()
			.map((resourceMap)=> {
				return [
					`const resourceMap = ${JSON.stringify(resourceMap)};`,
					`export default function(iconId){ const resourceLocation = resourceMap[iconId]; return resourceLocation ? fetch(["${baseUrl}", resourceLocation].join('/')).then((res)=> res.text()) : Promise.reject("Icon not found"); };`
				].join('\n');
			});

	return (iconStream)=> {
		return kefir.concat([
			!awsSkipUpload && iconStream.thru(pushToS3Bucket).map(({ key })=> ({ type: "log", value: `${key} successfully uploaded` })),
			iconStream.thru(generateResolver).map((code)=> ({ type: "code", value: code }))
		].filter(Boolean));
	};
};

const processStream = iconStream
	.thru(createAwsResolver({ awsAccessKey, awsAccessSecret, awsBucketName, awsSkipUpload }))
	.takeErrors(1);

kefir
	.merge([
		processStream
			.filter(({ type })=> type === "code")
			.map(({ value })=> value)
			.take(1)
			.flatMap((code)=> kefir.fromNodeCallback((cb)=> writeFile(path.resolve(process.cwd(), outputFolder, 'icon-resolve.autogenerated.js'), code, cb)))
			.map(()=> `Icon resolver module created successfully!`),
		processStream
			.filter(({ type })=> type === "log")
			.map(({ value })=> value)
	])
	.onValue(log)
	.onError((message)=> {
		warn(message);
		process.exit(1);
	});