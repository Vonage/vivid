import fs from 'fs';
import { dirname, resolve } from 'path';
import glob from 'glob';
import showdown from 'showdown';

export default build;

export {
	relocateStaticResources
}

const CONFIGS_LOOKUP_PATTERN = '+(common|components|docs)/**/stories/**/*.config.+(js|mjs)';
const DEFAULT_OUTPUT_FILE_SUFFIX = '.autogenerated.stories.js';

const FS_OPTIONS = { encoding: 'utf-8' };
const converter = new showdown.Converter();
converter.setFlavor('github');

async function build() {
	const configPaths = collectConfigurations();
	for (const configPath of configPaths) {
		await processJsConfiguration(configPath);
	}
}

function collectConfigurations() {
	console.info('collecting configurations...');
	const result = glob.sync(CONFIGS_LOOKUP_PATTERN);
	console.info(`... ${result.length} configuration/s collected`);
	return result;
}

async function processJsConfiguration(configPath) {
	console.info(`processing '${configPath}'...`);

	const config = (await import(resolve(configPath))).default;
	validateConfig(config);

	//	convert
	const configDir = dirname(configPath);
	let mdText = fs.readFileSync(resolve(configDir, config.sourcePath), FS_OPTIONS);
	if (config.mdPreProcess) {
		mdText = config.mdPreProcess(mdText);
	}
	let htmlText = converter.makeHtml(mdText);
	if (config.htmlPostProcess) {
		htmlText = config.htmlPostProcess(htmlText);
	}
	const htmlFinal = applyCommonTransformations(htmlText);
	const storyJs = buildStoryJs(config.story, htmlFinal);

	//	dump
	const outputFileName = config.outputName + (config.outputName.endsWith('.js')
		? ''
		: DEFAULT_OUTPUT_FILE_SUFFIX);
	fs.writeFileSync(resolve(configDir, outputFileName), storyJs, FS_OPTIONS);

	console.info('... done');
}

function validateConfig(config) {
	if (!config || typeof config !== 'object') {
		throw new Error(`config MUST be a non-null object; violator: ${config}`);
	}
	if (!config.sourcePath || typeof config.sourcePath !== 'string') {
		throw new Error(`'sourcePath' MUST be a non-empty string; got '${config.sourcePath}'`);
	}
	if (!config.outputName || typeof config.outputName !== 'string') {
		throw new Error(`'outputPath' MUST be a non-empty string; got '${config.outputName}'`);
	}
	if (!config.story || typeof config.story !== 'object') {
		throw new Error(`'story' MUST be a non-null object; got '${config.story}'`);
	}
	if (!config.story.title || typeof config.story.title !== 'string') {
		throw new Error(`'story.title' MUST be a non-empty string; got '${config.story.title}'`);
	}
	if (!config.story.name || typeof config.story.name !== 'string') {
		throw new Error(`'story.name' MUST be a non-empty string; got '${config.story.name}'`);
	}

	if ('mdPreProcess' in config && typeof config.mdPreProcess !== 'function') {
		throw new Error(`'mdPreProcess', when provided, MUST be a function; got '${config.mdPreProcess}'`);
	}
	if ('htmlPostProcess' in config && typeof config.htmlPostProcess !== 'function') {
		throw new Error(`'htmlPostProcess', when provided, MUST be a function; got '${config.htmlPostProcess}'`);
	}
}

function applyCommonTransformations(htmlInput) {
	return `
		<link rel="stylesheet" href="assets/css/md-stories.css">
		${htmlInput}
	`;
}

function buildStoryJs(story, html) {
	let result = `
	//	Autogenerated at ${new Date().toISOString()}
	//
	export default {
		title: '${story.title}'
	};

	export const ${story.name} = () => \`${html}\`;
	`;

	if (story.parameters) {
		result += `
	${story.name}.parameters = ${JSON.stringify(story.parameters)};
		`;
	}

	return result;
}

//	static resouces relocation utility
const
	AUTOGENERATED_FOLDER_RELATIVE = 'assets/autogenerated',
	AUTOGENERATED_FOLDER_ABSOLUTE = `.storybook/static/${AUTOGENERATED_FOLDER_RELATIVE}`;
fs.rmdirSync(AUTOGENERATED_FOLDER_ABSOLUTE, { recursive: true });
fs.mkdirSync(AUTOGENERATED_FOLDER_ABSOLUTE, { recursive: true });

function relocateStaticResources(htmlInput, srPaths) {
	if (!htmlInput || typeof htmlInput !== 'string') {
		throw new Error(`'htmlInput' MUST be a non-empty string; got '${htmlInput}'`);
	}
	if (!Array.isArray(srPaths) || !srPaths.length) {
		throw new Error(`'srPaths' MUST be a non-empty array; got '${srPaths}'`);
	}

	let htmlOutput = htmlInput;
	for (const originalPath of srPaths) {
		const autogeneratedFileName = originalPath.match(/\/(?<fn>[^/]+)$/).groups.fn.replace(/\.(?<ext>[^.]+)$/, '.autogenerated.$<ext>');
		fs.copyFileSync(originalPath, `${AUTOGENERATED_FOLDER_ABSOLUTE}/${autogeneratedFileName}`);
		htmlOutput = htmlOutput.replace(new RegExp(`(href|src)\s*=\s*"?${originalPath}"?`, 'g'), `$1="${AUTOGENERATED_FOLDER_RELATIVE}/${autogeneratedFileName}"`);
	}
	return htmlOutput;
}